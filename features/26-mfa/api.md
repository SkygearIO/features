# Overview

The following factors are supported:

- Time-Based One-Time Password [(TOTP)](https://tools.ietf.org/html/rfc6238)
- Out-of-band
  - SMS
  - Email
- Recovery code
- Bearer token

In the future, the below factors will be supported:

- [WebAuthn with CTAP2 or FIDO U2F](https://fidoalliance.org/specifications/)

The developer can configure the enforcement of MFA.

The session contains how the user was authenticated.

# Configuration

```yaml
mfa:
  # If enabled is false, the MFA API is disabled. THe user cannot register authenticator.
  # Default is false.
  enabled: false
  # Valid values are 'off', 'optional' or 'required'.
  # Default is 'optional'.
  #
  # 'off' means MFA is never required during authentication.
  #
  # 'optional' means MFA is required during authentication when the user has at least 1 activated authenticator. This is like how other major online services such as Google offer MFA.
  #
  # 'required' means MFA is always required during authentication.
  enforcement: 'optional'
  # The total maximum number of authenticator the user can register.
  # Valid values is [0, 15].
  # Default is 1.
  maximum: 1
  totp:
    # The maximum number of TOTP authenticator the user can register.
    # Valid values is [0, 5].
    # Default is 0.
    maximum: 0
  oob:
    sms:
      # The maximum number of OOB-SMS authenticator the user can register.
      # Valid values is [0, 5].
      # Default is 0.
      maximum: 0
    email:
      # The maximum number of OOB-Email authenticator the user can register.
      # Valid values is [0, 5].
      # Default is 0.
      maximum: 0
  bearer_token:
    # How many days the bearer token is valid. Default is 30.
    expire_in_days: 30
  recovery_code:
    # How many recovery code should be generated. Default is 16.
    count: 16
    # Enable listing the existing recovery code.
    # Some services like GitHub allow listing the existing recovery code.
    # By default listing is disabled, the user must regenerate a new set of
    # recovery code.
    list_enabled: false
```

# Configuration Recipes

## At most 1 TOTP or 1 OOB-SMS or 1 OOB-Email

```yaml
mfa:
  enabled: true
  enforcement: "optional"
  totp:
    maximum: 1
  oob:
    sms:
      maximum: 1
    email:
      maximum: 1
```

## At most 1 TOTP and 1 OOB-SMS and 1 OOB-Email

```yaml
mfa:
  enabled: true
  enforcement: "optional"
  maximum: 3
  totp:
    maximum: 1
  oob:
    sms:
      maximum: 1
    email:
      maximum: 1
```

## At most 1 TOTP

```yaml
mfa:
  enabled: true
  enforcement: "optional"
  totp:
    maximum: 1
```

## At most 1 OOB-SMS

```yaml
mfa:
  enabled: true
  enforcement: "optional"
  oob:
    sms:
      maximum: 1
```

# Endpoints

## POST /mfa/totp/new

### Request body

```JSON
{
  "display_name": "my TOTP"
}
```

- `display_name`: The display name of this TOTP authenticator.
- `authn_session_token`: Required only when there is no access token.

### Response body

```JSON
{
  "authenticator_id": "xxx",
  "authenticator_type": "totp",
  "secret": "secret"
}
```

- `secret`: The secret encoded in Base32 without padding.

## POST /mfa/totp/activate

### Request body

```JSON
{
  "authenticator_id": "xxx",
  "otp": "123456"
}
```

- `authenticator_id`: The ID of a TOTP authenticator to activate.
- `otp`: The one-time password generated by the secret of the authenticator.
- `authn_session_token`: Required only when there is no access token.

### Response body

```JSON
{
  "recovery_codes": ["xxx", "xxx"]
}
```

- `recovery_codes`: Present only when the activated authenticator is the first active authenticator.

## GET /mfa/totp/qrcode

## Query parameters

- `otpauth_uri`: The otpauth URI

### Response body

A PNG image of a QR code representing the given otpauth URI.

## POST /mfa/oob/new

### Request body

```JSON
{
  "channel": "sms",
  "phone": "+85223456789"
}
```

```JSON
{
  "channel": "email",
  "email": "user@example.com"
}
```

- `channel`: Either `sms` or `email`.
- `phone`: Required when `channel` is `sms`.
- `email`: Required when `channel` is `email`.
- `authn_session_token`: Required only when there is no access token.

### Response body

```JSON
{
  "authenticator_id": "xxx",
  "authenticator_type": "oob",
  "channel": "sms",
}
```

## POST /mfa/oob/trigger

### Request body

```JSON
{
  "authenticator_id": "xxx"
}
```

- `authenticator_id`: Optional when there is only one active OOB authenticator.
- `authn_session_token`: Required only when there is no access token.

### Response body

No response body. Only side effect is performed.

## POST /mfa/oob/activate

### Request body

```JSON
{
  "authenticator_id": "xxx",
  "code": "123456"
}
```

- `code`: The received code from the out-of-band channel.
- `authn_session_token`: Required only when there is no access token.

### Response body

```JSON
{
  "recovery_codes": ["xxx", "xxx"]
}
```

## POST /mfa/totp/authenticate

### Request body

```JSON
{
  "otp": "123456",
  "request_bearer_token": true,
  "authn_session_token": "xxx"
}
```

- `otp`: The one-time password. The OTP is tried with all active authenticators.
- `request_bearer_token`: Whether or not to issue a bearer token
- `authn_session_token`: The authentication session token.

### Response body

```JSON
{
  "user": { },
  "identity": { },
  "access_token": "xxx",
  "mfa_bearer_token": "yyy"
}
```

- `mfa_bearer_token`: Present only when `request_bearer_token` is `true`.

## POST /mfa/oob/authenticate

### Request body

```JSON
{
  "code": "123456",
  "request_bearer_token": true,
  "authn_session_token": "xxx"
}
```

- `code`: The code received from out-of-band channel. The code is tried with all valid codes.
- `request_bearer_token`: Whether or not to issue a bearer token
- `authn_session_token`: The authentication session token.

### Response body

```JSON
{
  "user": { },
  "identity": { },
  "access_token": "xxx",
  "mfa_bearer_token": "yyy"
}
```

- `mfa_bearer_token`: Present only when `request_bearer_token` is `true`.

## POST /mfa/recovery_code/authenticate

### Request body

```JSON
{
  "code": "XXXX-YYYY-ZZZZ",
  "authn_session_token": "xxx"
}
```

- `code`: A recovery code.
- `authn_session_token`: The authentication session token.

### Response body

```JSON
{
  "user": { },
  "identity": { },
  "access_token": "xxx"
}
```

## POST /mfa/bearer_token/authenticate

### Request body

```JSON
{
  "bearer_token": "xxx",
  "authn_session_token": "xxx"
}
```

- `bearer_token`: A bearer token.
- `authn_session_token`: The authentication session token.

### Response body

```JSON
{
  "user": { },
  "identity": { },
  "access_token": "xxx"
}
```

## GET /mfa/authenticators

### Request

No input is required.

### Response body

```JSON
{
  "authenticators": [
    {
      "id": "1",
      "type": "totp",
      "activated_at": "2019-07-19T00:00:00.000Z",
      "display_name": "totp-2edfdca2-3f05-41d2-bfd8-502725ee09a6"
    },
    {
      "id": "2",
      "type": "oob",
      "activated_at": "2019-07-19T00:00:00.000Z",
      "channel": "sms",
      "masked_phone": "+85223******"
    },
    {
      "id": "3",
      "type": "oob",
      "activated_at": "2019-07-19T00:00:00.000Z",
      "channel": "email",
      "masked_phone": "ab******@example.com"
    }
  ]
}
```

## DELETE /mfa/authenticator

### Request body

```JSON
{
  "authenticator_id": "XXX"
}
```

### Response body

No response body.

## POST /mfa/recovery_code/regenerate

### Request body

No request body

### Response body

```JSON
{
  "recovery_codes": ["xxx", "yyy"]
}
```

## GET /mfa/recovery_code

### Request body

No request body

### Response body

```JSON
{
  "recovery_codes": ["xxx", "yyy"]
}
```

## POST /mfa/bearer_token/revoke_all

### Request body

No request body

### Response body

No response body

# SDK API

The following functions are all in the namespace `skygear.auth.mfa`.

```typescript

// Register TOTP

interface CreateNewTOTPOptions {
  displayName: string;
  issuer: string;
  accountName: string;
}

interface CreateNewTOTPResult {
  authenticatorID: string;
  authenticatorType: "totp";
  secret: string;
  otpauthURI: string;
  qrCodeImageURL: string;
}

interface ActivateTOTPOptions {
  authenticatorID: string;
  otp: string;
}

interface ActivateTOTPResult {
  recoveryCodes?: string[];
}

interface GenerateOTPAuthURIOptions {
  secret: string;
  issuer: string;
  accountName: string;
}

async function createNewTOTP(options: CreateNewTOTPOptions): Promise<CreateNewTOTPResult>;
async function activateTOTP(options: ActivateTOTPOptions): Promise<ActivateTOTPResult>;

function generateOTPAuthURI(options: GenerateOTPAuthURIOptions): string;
function generateOTPAuthURIQRCodeImageURL(otpauthURI: string): string;

// Register OOB

type CreateNewOOBOptions = CreateNewOOBSMSOptions | CreateNewOOBEmailOptions;

interface CreateNewOOBSMSOptions {
  channel: "sms";
  phone: string;
}

interface CreateNewOOBEmailOptions {
  channel: "email";
  email: string;
}

interface TriggerOOBOptions {
  authenticatorID?: string;
}

interface ActivateOOBOptions {
  authenticatorID: string;
  code: string;
}

interface CreateNewOOBResult {
  authenticatorID: string;
  authenticatorType: "oob";
  channel: "sms" | "email";
}

interface ActivateOOBResult {
  recoveryCodes?: string[];
}

async function createNewOOB(options: CreateNewOOBOptions): Promise<CreateNewOOBResult>;
async function triggerOOB(options?: TriggerOOBOptions): Promise<void>;
async function activateOOB(opitons: ActivateOOBOptions): Promise<ActivateOOBResult>;

// Error inspection

interface AuthenticationSession {
  token: string;
  step: "identity" | "mfa";
}

interface AuthContainer {
  authenticationSession?: AuthenticationSession;
}

// Authenticate

interface AuthenticateWithTOTPOptions {
  otp: string;
  skipMFAForCurrentDevice?: boolean;
}

interface AuthenticateWithOOBOptions {
  code: string;
  skipMFAForCurrentDevice?: boolean;
}

interface AuthenticateWithRecoveryCodeOptions {
  code: string;
};

async function authenticateWithTOTP(options: AuthenticateWithTOTPOptions): Promise<User>;

async function authenticateWithOOB(options: AuthenticateWithOOBOptions): Promise<User>;

async function authenticateWithRecoveryCode(options: AuthenticateWithRecoveryCodeOptions): Promise<User>;

// Authenticator management

type Authenticator = TOTPAuthenticator | OOBSMSAuthenticator | OOBEmailAuthenticator;

interface TOTPAuthenticator {
  id: string;
  type: "totp";
  activatedAt: Date;
  displayName: string;
}

interface OOBSMSAuthenticator {
  id: string;
  type: "oob";
  activatedAt: Date;
  channel: "sms";
  maskedPhone: string;
}

interface OOBEmailAuthenticator {
  id: string;
  type: "oob";
  activatedAt: Date;
  channel: "email";
  maskedEmail: string;
}

interface RegenerateRecoveryCodeResult {
  recoveryCodes: string[];
}

interface ListRecoveryCodeResult {
  recoveryCodes: string[];
}

async function getAuthenticators(): Promise<Authenticator[]>;
async function deleteAuthenticator(authenticatorID: string): Promise<void>;
async function regenerateRecoveryCode(): Promise<RegenerateRecoveryCodeResult>;
async function listRecoveryCode(): Promise<ListRecoveryCodeResult>;
async function revokeAllTrustedDevices(): Promise<void>;
```

# Use Cases

## Registration

### SDK

```typescript
try {
  await skygear.auth.login("user@example.com", "password");
} catch (e) {
  const authnSession = skygear.auth.authenticationSession;
  if (authnSession != null && authnSession.step === "mfa") {
    navigateToRegisterMFAScreen(authnSession);
    return;
  }
  // Handle any other error.
}
```

```typescript
// Present an UI to let the user to choose authenticator.
// Suppose the user chose TOTP.

// Present an UI to let the user to optionally name the TOTP authenticator.

const displayName = textInput.value;
const {
  authenticatorID,
  // In simpliest case, just use the QR code image URL.
  qrCodeImageURL,
  // Or the developer can generate the QR code with the key URI.
  otpauthURI,
  // Or the developer can generate the key URI by themselves with the Base32 encoded secret.
  secret,
} = await skygear.auth.mfa.createNewTOTP({
  displayName,
  issuer: "My App",
  accountName: "user@example.com",
});

// The image URL is ready for use.
image.src = qrCodeImageURL;

// Present an UI to instruct the user to input the OTP.
const otp = textInput.value;
const { recoveryCodes } = await skygear.auth.mfa.activateTOTP({
  authenticatorID,
  otp,
});
```

```typescript
// Present an UI to let the user to choose authenticator.
// Suppose the user chose OOB.

// Present an UI to instruct the user to input a phone number.
const e164number = textInput.value;
const { authenticatorID } = await skygear.auth.mfa.createNewOOB({
  channel: "sms",
  phone: e164number,
});

// Present an UI to instruct the user to check SMS.

// Present an UI to offer the user to trigger again in case the delivery failed.
await triggerOOB({
  authenticatorID,
});

// Present an UI to instruct the user to input the recevied code.
const code = textInput.value;
const { recoveryCodes } = await skygear.auth.mfa.activateOOB({
  authenticatorID,
  code,
});
```

```typescript
// Check if recoveryCodes is present and present them to the user.
// Ask the user to remember them and keep them safe.
if (recoveryCodes) {
  navigateToDisplayRecoveryCodeScreen(recoveryCodes);
}
```

### HTTP

- POST /login
- Receive Authentication Session Error
- POST /mfa/totp/new
- Receive the secret
- Add the secret to an Authenticator Application
- POST /mfa/totp/activate
- Receive the recovery codes if the new authenticator is the first one.

## Authentication

### SDK

```typescript
try {
  await skygear.auth.login("user@example.com", "password");
} catch (e) {
  if (skygear.auth.authenticationSession == null) {
    throw e;
  }

  const authenticators = await skygear.auth.mfa.getAuthenticators();
  // Present the authenticators to the user and let them choose
  // which one they want to use.

  // Suppose they chose OOB
  await skygear.mfa.triggerOOB({
    authenticatorID: authenticators[0].id,
  });

  // Present an UI to instruct the user to check SMS.
  // Present an UI to offer the user to trigger resend.
  // Present an UI to instruct the user to input the received code.
  // Present an UI to offer the user to skip MFA for 30 days.

  const code = textInput.value;
  const user = await skygear.auth.mfa.authenticateWithOOB({
    code,
    skipMFAForCurrentDevice: true,
  });
}
```

The client SDK has the bearer token transparently.

### HTTP

#### TOTP

- POST /login
- Receive Authentication Session Error
- Get the one-time password from Authenticator Application
- POST /mfa/totp/authenticate

#### OOB

- POST /login
- Receive Authentication Session Error
- POST /mfa/oob/trigger
- Receive code from the out-of-band channel
- POST /mfa/oob/authenticate

#### Bearer token

- POST /login
- Receive Authentication Session Error
- Retrieve the saved bearer token from device storage
- POST /mfa/bearer_token/authenticate

#### Recovery code

- POST /login
- Receive Authentication Session Error
- POST /mfa/recovery_code/authenticate

## List authenticators in settings screen

### SDK

```typescript
const authenticators = await skygear.auth.mfa.getAuthenticators();
// [
//   {
//     id: "1",
//     type: "totp",
//     activatedAt: new Date("2019-07-19T00:00:00.000Z"),
//     displayName: "totp-2edfdca2-3f05-41d2-bfd8-502725ee09a6",
//   },
//   {
//     id: "2",
//     type: "oob",
//     activatedAt: new Date("2019-07-19T00:00:00.000Z"),
//     channel: "sms",
//     maskedPhone: "+85223******",
//   },
//   {
//     id: "3",
//     type: "oob",
//     activatedAt: new Date("2019-07-19T00:00:00.000Z"),
//     channel: "email",
//     maskedEmail: "ab*****@example.com",
//   },
// ]

const hasTOTP = authenticators.filter(a => a.type === "totp").length > 0;
const hasOOB = authenticators.filter(a => a.type === "oob").length > 0;
```

### HTTP

- GET /mfa/authenticators

## Delete an authenticator

### SDK

```typescript
const authenticators = await skygear.auth.mfa.getAuthenticators();
// Present an UI to show the list of authenticators and
// let the user to choose which one to delete.

// Suppose the user wants to delete the first one.
const { id } = authenticators[0];
await skygear.auth.mfa.deleteAuthenticator(id);
```

### HTTP

- DELETE /mfa/authenticator

## Revoke all trusted devices

### SDK

```typescript
// The user can revoke all trusted devices so that subsequent authentications
// require MFA.
await skygear.auth.mfa.revokeAllTrustedDevices();
```

### HTTP

- POST /mfa/bearer_token/revoke_all

## List recovery codes

### SDK

```typescript
// If listing is enabled, the user can list the existing recovery code.
const { recoveryCodes } = await skygear.auth.mfa.listRecoveryCode();
// Present an UI to show the list of recovery codes to the user.
```

### HTTP

- GET /mfa/recovery_code

## Regenerate recovery codes

### SDK

```typescript
// If listing is disabled, the user must regenerate a new set of recovery code.
const { recoveryCodes } = await skygear.auth.mfa.regenerateRecoveryCode();
// Present an UI to show the list of recovery codes to the user.
```

### HTTP

- POST /mfa/recovery_code/regenerate

## Account recovery

### SDK

```typescript
// Suppose the user has lost their TOTP device.
// The MFA screen of the application should display
// a button to allow the user to enter recovery code.
// Since recovery code is consumable, the application should
// prompt the user to generate a new set of recovery code to
// prevent account lockout.
const recoveryCode = textInput.value;
const user = await skygear.auth.mfa.authenticateWithRecoveryCode(recoveryCode);
```

### HTTP

- POST /mfa/recovery_code/authenticate

## Lost device or changed phone number

### SDK

```typescript
// Suppose the user has lost their device or changed their phone number.
// Under default settings, the number of authenticators is 1.
// So the user should first remove the old authenticator otherwise
// new registration will never succeed.

// Present an UI to let the user to choose an authenticator to delete.
const authenticators = await skygear.auth.mfa.getAuthenticators();
const authenticatorID = authenticators[0].id;
await skygear.auth.mfa.deleteAuthenticator(authenticatorID);

// Guide the user to setup a new authenticator.
// This flow should be the same as the original Registration flow.
```

### HTTP

- GET /mfa/authenticators
- DELETE /mfa/authenticator

## Step-up MFA from an existing session

### Microservice

```javascript
function someSensitiveOperation(req, res) {
  const now = new Date();
  const aid = req.headers.get("x-skygear-authenticator-id");
  const atime = req.headers.get("x-skygear-authenticator-updated-at");
  if (aid && (now - (new Date(atime))) <= 5 * 60 * 1000) {
    // MFA was involved in the session and is fresh enough
    // Continue our business logic...
  } else {
    // Tell our application that step-up MFA is required.
    // The error format is up to the application.
    res.write(401, "step-up-mfa");
  }
}
```

### SDK

```typescript
const response = await skygear.fetch("/someSensitiveOperation", {
  method: "POST",
  body: JSON.stringify(payload),
});
const text = await response.text();
if (response.status === 401 && text === "step-up-mfa") {
  navigateToAuthenticationMFAScreen();
}
```

# Delete authenticator

Deleting the authenticator will invalidate the associated sessions.

# Interaction between Client SDK and MFA

- The Client SDK must save the bearer token it receives.
- The Client SDK must try to handle authentication session error with the bearer token once.

## Bearer token flow

The following pseudo code demonstrate the bearer token flow

```typescript
// This function is skygear.auth.login
async function login(loginID: string, password: string): Promise<User> {
  try {
    return _login("user@example.com", "password");
  } catch (e) {
    return beginBearerTokenFlow(e);
  }
}

async function beginBearerTokenFlow(error: unknown): Promise<User> {
  // Re-raise the error if it is not authentication session error
  const authnSession = skygear.auth.authenticationSession;
  if (authnSession == null) {
    throw error;
  }
  // Re-raise the error if the step is not MFA.
  const { step } = authnSession;
  if (step !== "mfa") {
    throw error;
  }
  const { token: authn_session_token } = authnSession;

  // Retrieve the saved bearer token
  // The token may be in cookie so it cannot be retrieved.
  let bearer_token;
  try {
    bearer_token = await getBearerToken();
  } catch {
    throw error;
  }

  // Therefore we must try to authenticate once
  try {
    return authenticateWithBearerToken({
      bearer_token,
      authn_session_token:,
    });
  } catch {
    throw error;
  }
}
```

# Authenticator Characteristics

## TOTP

The implementation conforms to [RFC6238](https://tools.ietf.org/html/rfc6238) and [RFC4226](https://tools.ietf.org/html/rfc4226).

In order to be compatible existing Authenticator Applications like Google Authenticator

- The algorithm is always HMAC-SHA1.
- The code is always 6-digit long.
- The valid period of a code is always 30 seconds.

To deal with clock skew, the code generated before or after the current time are also accepted.

### Example

- `123456`

## OOB

The code is 6-digit long and valid for 5 minutes.

### Example

- `123456`

## Recovery code

The code is cryptographically secure random 10-letter string in Crockford's Base32 alphabet.

### Example

- `a6ef6748a7`

## Bearer token

- The token is a cryptographically secure random string of 256 bits (32 bytes) in hex encoding.

### Example

- `3e52f564f8f76bbe38b93ad9897601577227612b5d496de2aab443a67d23ea94`

## Vulnerability to brute force attack

Since the code of each authenticator is short, it is vulnerable to brute force attack. Authentication attempts should have rate limiting to prevent brute force attack.
