# Overview

The following factors are supported:

- Time-Based One-Time Password [(TOTP)](https://tools.ietf.org/html/rfc6238)
- Out-of-band
  - SMS
  - Email
- Recovery code
- Bearer token

In the future, the below factors will be supported:

- [WebAuthn with CTAP2 or FIDO U2F](https://fidoalliance.org/specifications/)

The developer can configure the enforcement of MFA.

The access token contains how the user was authenticated.

# Configuration

```yaml
mfa:
  # 'optional' or 'required'
  #
  # 'optional' means the user is free to register a new authenticator.
  # When a user has at least one active authenticator, the user must login with MFA.
  # This is like how other online services such as Google and Facebook offer MFA.
  #
  # 'required' means the user must login with MFA.
  # This is like how banking services offer MFA.
  #
  # Default is 'optional'
  enforcement: 'optional'
  bearer_token:
    # How many days the bearer token is valid. Default is 30.
    expire_in_days: 30
  recovery_code:
    # How many recovery code should be generated. Default is 16.
    count: 16
    # Enable listing the existing recovery code.
    # Some services like GitHub allow listing the existing recovery code.
    # By default listing is disabled, the user must regenerate a new set of
    # recovery code.
    list_enabled: false
```

# Endpoints

## POST /mfa/totp/new

### Request body

```JSON
{
  "display_name": "my TOTP"
}
```

- `display_name`: Optional. Randomly generated if not provided.

### Response body

```JSON
{
  "authenticator_id": "xxx",
  "authenticator_type": "totp",
  "secret": "secret"
}
```

- `secret`: The secret encoded in Base32 without padding.

## POST /mfa/totp/activate

### Request body

```JSON
{
  "authenticator_id": "xxx",
  "otp": "123456"
}
```

- `authenticator_id`: The ID of a TOTP authenticator to activate.
- `otp`: The one-time password generated by the secret of the authenticator.

### Response body

```JSON
{
  "recovery_codes": ["xxx", "xxx"]
}
```

- `recovery_codes`: Present only when the activated authenticator is the first active authenticator.

## GET /mfa/totp/qrcode

## Query parameters

- `otpauth_uri`: The otpauth URI

### Response body

A PNG image of a QR code representing the given otpauth URI.

## POST /mfa/oob/new

### Request body

```JSON
{
  "channel": "sms",
  "phone": "+85223456789"
}
```

```JSON
{
  "channel": "email",
  "email": "user@example.com"
}
```

- `channel`: Either `sms` or `email`.
- `phone`: Required when `channel` is `sms`.
- `email`: Required when `channel` is `email`.

### Response body

```JSON
{
  "authenticator_id": "xxx",
  "authenticator_type": "oob",
  "channel": "sms",
}
```

## POST /mfa/oob/trigger

### Request body

```JSON
{
  "authenticator_id": "xxx"
}
```

### Response body

No response body. Only side effect is performed.

## POST /mfa/oob/activate

### Request body

```JSON
{
  "authenticator_id": "xxx",
  "code": "123456"
}
```

- `code`: The received code from the out-of-band channel.

### Response body

```JSON
{
  "recovery_codes": ["xxx", "xxx"]
}
```

## POST /mfa/totp/authenticate

### Request body

```JSON
{
  "authenticator_id": "xxx",
  "otp": "123456",
  "request_bearer_token": true
}
```

- `authenticator_id`: Optional when there is only one active TOTP authenticator.
- `otp`: The one-time password
- `request_bearer_token`: Whether or not to issue a bearer token

### Response body

```JSON
{
  "user": { },
  "identity": { },
  "access_token": "xxx",
  "mfa_bearer_token": "yyy"
}
```

- `mfa_bearer_token`: Present only when `request_bearer_token` is `true`.

## POST /mfa/oob/authenticate

### Request body

```JSON
{
  "authenticator_id": "xxx",
  "code": "123456",
  "request_bearer_token": true
}
```

- `authenticator_id`: Optional when there is only one active OOB authenticator.
- `code`: The code received from out-of-band channel.
- `request_bearer_token`: Whether or not to issue a bearer token

### Response body

```JSON
{
  "user": { },
  "identity": { },
  "access_token": "xxx",
  "mfa_bearer_token": "yyy"
}
```

- `mfa_bearer_token`: Present only when `request_bearer_token` is `true`.

## POST /mfa/recovery_code/authenticate

### Request body

```JSON
{
  "code": "XXXX-YYYY-ZZZZ"
}
```

- `code`: A recovery code.

### Response body

```JSON
{
  "user": { },
  "identity": { },
  "access_token": "xxx"
}
```

## POST /mfa/bearer_token/authenticate

### Request body

```JSON
{
  "bearer_token": "xxx"
}
```

- `bearer_token`: A bearer token.

### Response body

```JSON
{
  "user": { },
  "identity": { },
  "access_token": "xxx"
}
```

## GET /mfa/authenticators

### Request

No input is required.

### Response body

```JSON
{
  "authenticators": [
    {
      "id": "1",
      "type": "totp",
      "activated_at": "2019-07-19T00:00:00.000Z",
      "display_name": "totp-2edfdca2-3f05-41d2-bfd8-502725ee09a6"
    },
    {
      "id": "2",
      "type": "oob",
      "activated_at": "2019-07-19T00:00:00.000Z",
      "channel": "sms",
      "masked_phone": "+85223******"
    },
    {
      "id": "3",
      "type": "oob",
      "activated_at": "2019-07-19T00:00:00.000Z",
      "channel": "email",
      "masked_phone": "ab******@example.com"
    }
  ]
}
```

## DELETE /mfa/authenticator

### Request body

```JSON
{
  "authenticator_id": "XXX"
}
```

### Response body

No response body.

## POST /mfa/recovery_code/regenerate

### Request body

No request body

### Response body

```JSON
{
  "recovery_codes": ["xxx", "yyy"]
}
```

## GET /mfa/recovery_code

### Request body

No request body

### Response body

```JSON
{
  "recovery_codes": ["xxx", "yyy"]
}
```

## POST /mfa/bearer_token/revoke_all

### Request body

No request body

### Response body

No response body

## MFA required error

```JSON
{
  "name": "MFARequired",
  "code": "9999",
  "message": "MFA required",
  "info": {
    "mfa_token": "xxx"
  }
}
```

# SDK API

The following functions are all in the namespace `skygear.auth.mfa`.

```typescript
// Register TOTP

interface CreateNewTOTPResult {
  authenticatorID: string;
  authenticatorType: "totp";
  secret: string;
}

interface ActivateTOTPResult {
  recoveryCodes?: string[];
}

interface GenerateOTPAuthURIOptions {
  secret: string;
  issuer: string;
  accountName: string;
}

async function createNewTOTP(displayName?: string): Promise<CreateNewTOTPResult>;
async function activateTOTP(authenticatorID: string, otp: string): Promise<ActivateTOTPResult>;
function generateOTPAuthURI(options: GenerateOTPAuthURIOptions): string;
function generateOTPAuthURIQRCodeImageURL(otpauthURI: string): string;

// Register OOB

type CreateNewOOBOptions = CreateNewOOBSMSOptions | CreateNewOOBEmailOptions;

interface CreateNewOOBSMSOptions {
  channel: "sms";
  phone: string;
}

interface CreateNewOOBEmailOptions {
  channel: "email";
  email: string;
}

interface CreateNewOOBResult {
  authenticatorID: string;
  authenticatorType: "oob";
  channel: "sms" | "email";
}

interface ActivateOOBResult {
  recoveryCodes?: string[];
}

async function createNewOOB(options: CreateNewOOBOptions): Promise<CreateNewOOBResult>;
async function triggerOOB(authenticatorID?: string): Promise<void>;
async function activateOOB(authenticatorID: string, code: string): Promise<ActivateOOBResult>;

// Error inspection

function isMFARequiredError(err: unknown): boolean;

// Authenticate

interface TOTPAuthenticateOptions {
  authenticatorID?: string;
  otp: string;
  skipMFAForCurrentDevice?: boolean;
}

async function authenticateWithTOTP(options: TOTPAuthenticateOptions): Promise<User>;

interface OOBAuthenticateOptions {
  authenticatorID?: string;
  code: string;
  skipMFAForCurrentDevice?: boolean;
}

async function authenticateWithOOB(options: OOBAuthenticateOptions): Promise<User>;

async function authenticateWithRecoveryCode(code: string): Promise<User>;

// Authenticator management

type Authenticator = TOTPAuthenticator | OOBSMSAuthenticator | OOBEmailAuthenticator;

interface TOTPAuthenticator {
  id: string;
  type: "totp";
  activatedAt: Date;
  displayName: string;
}

interface OOBSMSAuthenticator {
  id: string;
  type: "oob";
  activatedAt: Date;
  channel: "sms";
  maskedPhone: string;
}

interface OOBEmailAuthenticator {
  id: string;
  type: "oob";
  activatedAt: Date;
  channel: "email";
  maskedEmail: string;
}

interface RegenerateRecoveryCodeResult {
  recoveryCodes: string[];
}

interface ListRecoveryCodeResult {
  recoveryCodes: string[];
}

async function getAuthenticators(): Promise<Authenticator[]>;
async function deleteAuthenticator(authenticatorID: string): Promise<void>;
async function regenerateRecoveryCode(): Promise<RegenerateRecoveryCodeResult>;
async function listRecoveryCode(): Promise<ListRecoveryCodeResult>;
async function revokeAllTrustedDevices(): Promise<void>;
```

# Use Cases

## Registration

### SDK

```typescript
try {
  await skygear.auth.login("user@example.com", "password");
} catch (e) {
  if (skygear.isMFARequiredError(e)) {
    navigateToRegisterMFAScreen();
    return;
  }
  // Handle any other error.
}
```

```typescript
// Present an UI to let the user to choose authenticator.
// Suppose the user chose TOTP.

// Present AN UI to let the user to optionally name the TOTP authenticator.

const displayName = textInput.value;
const { authenticatorID, secret } = await skygear.auth.mfa.createNewTOTP(displayName);

// Present to the secret to the user and let the user
// to add the secret to their TOTP application, such as Authy and Google Authenticator.
// Or preferably generate an otpauth URI.

const otpauthURI = skygear.auth.mfa.generateOTPAuthURI({
  secret,
  issuer: "My App",
  accountName: "user@example.com",
});

// If the developer can either generate the QR code by themselves or generate an QR code image URL.
const qrcodeImageURL = skygear.auth.mfa.generateOTPAuthURIQRCodeImageURL(otpauthURI);
image.src = qrcodeImageURL;

// Present an UI to instruct the user to input the OTP.
const otp = textInput.value;
const { recoveryCodes } = await skygear.auth.mfa.activateTOTP(authenticatorID, otp);
```

```typescript
// Present an UI to let the user to choose authenticator.
// Suppose the user chose OOB.

// Present an UI to instruct the user to input a phone number.
const e164number = textInput.value;
const { authenticatorID } = await skygear.auth.mfa.createNewOOB({ phone: e164number });

// Present an UI to instruct the user to check SMS.

// Present an UI to offer the user to trigger again in case the delivery failed.
await triggerOOB(authenticatorID);

// Present an UI to instruct the user to input the recevied code.
const code = textInput.value;
const { recoveryCodes } = await skygear.auth.mfa.activateOOB(authenticatorID, code);
```

```typescript
// Check if recoveryCodes is present and present them to the user.
// Ask the user to remember them and keep them safe.
if (recoveryCodes) {
  navigateToDisplayRecoveryCodeScreen(recoveryCodes);
}
```

### HTTP

- POST /login
- Receive MFA required error with MFA token
- POST /mfa/totp/new
- Receive the secret
- Add the secret to an Authenticator Application
- POST /mfa/totp/activate
- Receive the recovery codes if the new authenticator is the first one.

## Authentication

### SDK

```typescript
try {
  await skygear.auth.login("user@example.com", "password");
} catch (e) {
  // Re-raise other error.
  if (!skygear.isMFARequiredError(e)) {
    throw e;
  }

  const authenticators = await skygear.auth.mfa.getAuthenticators();
  // Present the authenticators to the user and let them choose
  // which one they want to use.

  // Suppose they chose OOB
  await skygear.mfa.triggerOOB(authenticators[0].id);

  // Present an UI to instruct the user to check SMS.
  // Present an UI to offer the user to trigger resend.
  // Present an UI to instruct the user to input the received code.
  // Present an UI to offer the user to skip MFA for 30 days.

  const code = textInput.value;
  const user = await skygear.auth.mfa.authenticateWithOOB({ authenticatorID, code }, { skipMFAForCurrentDevice: true});
}
```

The client SDK has the bearer token transparently.

### HTTP

#### TOTP

- POST /login
- Receive MFA required error with MFA token
- Get the one-time password from Authenticator Application
- POST /mfa/totp/authenticate

#### OOB

- POST /login
- Receive MFA required error with MFA token
- POST /mfa/oob/trigger
- Receive code from the out-of-band channel
- POST /mfa/oob/authenticate

#### Bearer token

- POST /login
- Receive MFA required error with MFA token
- Retrieve the saved bearer token from device storage
- POST /mfa/bearer_token/authenticate

#### Recovery code

- POST /login
- Receive MFA required error with MFA token
- POST /mfa/recovery_code/authenticate

## List authenticators in settings screen

### SDK

```typescript
const authenticators = await skygear.auth.mfa.getAuthenticators();
// [
//   {
//     id: "1",
//     type: "totp",
//     activatedAt: new Date("2019-07-19T00:00:00.000Z"),
//     displayName: "totp-2edfdca2-3f05-41d2-bfd8-502725ee09a6",
//   },
//   {
//     id: "2",
//     type: "oob",
//     activatedAt: new Date("2019-07-19T00:00:00.000Z"),
//     channel: "sms",
//     maskedPhone: "+85223******",
//   },
//   {
//     id: "3",
//     type: "oob",
//     activatedAt: new Date("2019-07-19T00:00:00.000Z"),
//     channel: "email",
//     maskedEmail: "ab*****@example.com",
//   },
// ]

const hasTOTP = authenticators.filter(a => a.type === "totp").length > 0;
const hasOOB = authenticators.filter(a => a.type === "oob").length > 0;
```

### HTTP

- GET /mfa/authenticators

## Delete an authenticator

### SDK

```typescript
const authenticators = await skygear.auth.mfa.getAuthenticators();
// Present an UI to show the list of authenticators and
// let the user to choose which one to delete.

// Suppose the user wants to delete the first one.
const { id } = authenticators[0];
await skygear.auth.mfa.deleteAuthenticator(id);
```

### HTTP

- DELETE /mfa/authenticator

## Revoke all trusted devices

### SDK

```typescript
// The user can revoke all trusted devices so that subsequent authentications
// require MFA.
await skygear.auth.mfa.revokeAllTrustedDevices();
```

### HTTP

- POST /mfa/bearer_token/revoke_all

## List recovery codes

### SDK

```typescript
// If listing is enabled, the user can list the existing recovery code.
const { recoveryCodes } = await skygear.auth.mfa.listRecoveryCode();
// Present an UI to show the list of recovery codes to the user.
```

### HTTP

- GET /mfa/recovery_code

## Regenerate recovery codes

### SDK

```typescript
// If listing is disabled, the user must regenerate a new set of recovery code.
const { recoveryCodes } = await skygear.auth.mfa.regenerateRecoveryCode();
// Present an UI to show the list of recovery codes to the user.
```

### HTTP

- POST /mfa/recovery_code/regenerate

# Access Token, amr and MFA Token

## amr

The access token includes a new claim [amr](https://openid.net/specs/openid-connect-core-1_0.html).

## MFA Token

An access token is said to be a MFA Token if it does not have `mfa` in its `amr` array.

An access token issued by `/mfa/*/authenticate` must have `mfa` in its `amr` array.

## Mapping between existing authentication method and factor name

|Method|Factor Name|
|------|-----------|
|password|pwd|
|oauth|oauth|
|custom_token|custom_token|

If the method has defined value in [RFC8176](https://tools.ietf.org/html/rfc8176), the value is used.

When the user authenticates with one factor, the value is singleton array of the name of that factor.

When the user authenticates with MFA factor, `mfa` is included and the authenticator type is added.

When the access token originally has MFA factor, the factor is removed first.

In the case the authenticator is OOB, the channel is also added.

## Example

### Authenticate with password

```JSON
{
  "amr": ["pwd"]
}
```

### Authenticate with password and then TOTP

```JSON
{
  "amr": ["pwd", "mfa", "totp"]
}
```

### Authenticate with password and then OOB SMS

```JSON
{
  "amr": ["pwd", "mfa", "oob", "sms"]
}
```

### Authenticate with password and then OOB Email

```JSON
{
  "amr": ["pwd", "mfa", "oob", "email"]
}
```

### Authenticate with password and then bearer token

```JSON
{
  "amr": ["pwd", "mfa", "bearer_token"]
}
```

### Authenticate with password and then recovery code

```JSON
{
  "amr": ["pwd", "mfa", "recovery_code"]
}
```

### Authenticate with OAuth and then TOTP

```JSON
{
  "amr": ["oauth", "mfa", "totp"]
}
```

## Injection of amr into HTTP headers

The gateway injects the value of `amr` into HTTP header `x-skygear-auth-amr` as a comma separated value.

### Example

Given

```JSON
{
  "amr": ["pwd", "mfa", "oob", "sms"]
}
```

The injected header is

```
x-skygear-auth-amr: pwd,mfa,oob,sms
```

The usefulness of this injection is to allow microservice to determine whether or not the user was authenticated with MFA.
If the developer determines a given resource require MFA, they should reject the request and return an error to the client.
On client-side, the developer should detect this error and guide the user to either associate a new authenticator or
authenticate with existing authenticators.
Note that the error the developer generate generally cannot use `skygear.isMFARequiredError` because
it can only detect the error generated by the Auth gear.

# MFA required

## MFA required endpoint

When an endpoint is MFA required, it does not accept MFA token. That is, the access token it accepts must have `mfa` in its `amr` array.

## MFA Token accepting endpoints

- GET /mfa/authenticators

This endpoint accepts MFA token so the user can see what authenticators they can use.

- POST /mfa/totp/new
- POST /mfa/totp/activate
- POST /mfa/oob/new
- POST /mfa/oob/activate

These endpoints accept MFA token only when the user has no authenticators. When the user has no authenticators, they must be offered a way to add the very first authenticator. When the user has at least one authenticator, then these endpoints reject MFA token. This prevents an attacker who knows the first factor (such as password credentials) to register arbitrary authenticators.

- POST /mfa/totp/authenticate
- POST /mfa/oob/authenticate
- POST /mfa/recovery_code/authenticate
- POST /mfa/bearer_token/authenticate

By definition, they accept MFA token.

## Access Token issuing endpoints

- signup
- login
- OAuth
- Custom Token

Basically any endpoints that do authentication.

## Condition of MFA required

To determine whether MFA is required, configuration, the endpoint and number of authenticators  are taken into consideration.

|enforcement|number of authenticators|endpoint|MFA required|
|-----------|------------------------|--------|------------|
|optional|0|MFA Token accepting endpoints|false|
|optional|0|Any other endpoints|false|
|optional|>0|MFA Token accepting endpoints|false|
|optional|>0|Any other endpoints|true|
|required|0|MFA Token accepting endpoints|false|
|required|0|Any other endpoints|true|
|required|>0|MFA Token accepting endpoints|false|
|required|>0|Any other endpoints|true|

## MFA required error

A MFA required endpoint rejects any request with a MFA token with a MFA required error. This error has its own error code and is identifiable in client SDK.

## Issue of MFA Token

When access token issuing endpoints returns a MFA required error, the error includes a MFA token.
