# Alternative to Auth hooks

## How Auth hooks look like now

Every auth operation has its corresponding event. For example, `signup` operation has the `signup` event.

For each event, the hook can be `async` and `sync`, `before` and `after`. Therefore the `signup` operation
has the following hooks

- `before_signup_sync`
- `before_signup_async`
- `after_signup_sync`
- `after_signup_async`

## Usage of auth hooks

Suppose we are writing an application that needs to integrate with an existing user system.
Let's name that external user system X.
The app has its own user system which is clearly the Auth gear. During signup, the user of
the app can optionally provide a user ID from X. In that case, the app must associate
the new skygear user with that user ID. Or the app must register a new user in X. In either
case the new skygear user must have an associated user ID from X.

An implementation of using auth hooks may look like

```typescript
async function before_signup_sync(data) {
  if (data.metadata.x_user_id) {
    await verify_x_user_id(data.metadata.x_user_id);
  }
}

async function after_signup_sync(data) {
  let x_user_id = data.metadata.x_user_id;
  if (!x_user_id) {
    x_user_id = await signup_x_user(...);
  }
  // Persist x_user_id and data to my database.
}
```

The developer needs to choose the correct variant of the hooks and split the flow in separate
functions.

## How to implement the signup flow without hooks

If the Auth gear has public API, then the developer can implement the flow in a readable way.

```typescript
async function my_signup(signup_payload) {
  const { email, password } = signup_payload;
  let { x_user_id } = signup_payload;
  const { skygear_user_id, access_token } = await skygear_auth_signup({
    loginIDs: {
      email,
    },
    password,
  });
  if (!x_user_id) {
    x_user_id = signup_x_user(...);
  }

  // Persist x_user_id and skygear_user_id to my database

  // Return access_token for the client SDK to persist user session.
  // More details on this.
  return { skygear_user_id, access_token };
}
```

The advantage is that the control is now inverted. Instead of the Auth gear taking charge of the flow,
the application does. We no longer need to define the meaning of `before` and `after` of each event.
The developer can control the flow in any way he wants.

The main caveat is that the response is generated by the application, the client SDK cannot understand it.
Therefore, the client SDK need to expose a way to persist user session manually. This means we need to
expose a previously private user session persistence routine.

```typescript
async function signup(signup_payload) {
  const response = await fetch("https://myserver.com/signup", {
    method: "POST",
    body: JSON.stringify(signup_payload),
  });
  throwForStatus(response);
  const json = await response.json();
  throwForErrorBody(json);
  const { skygear_user_id, access_token } = json;
  // The function name is intended to be long to draw developer's attention
  // that it is not function that they should be using unless
  // they know what they are doing.
  skygear.auth.setUserSessionForCustomAuthFlow({
    user_id: skygear_user_id,
    access_token: access_token,
  });
}
```

Any other caveat is that we must disallow the original signup of the Auth gear from being invoked
in other ways. Failing to do this will cause the application fail to uphold the invariant that
every skygear user must have an associated user ID from X. A simple way to do this is support
configuring auth operation to be master-key required.

## Other possibilities

We may still have hooks, but they are always `after` and `async` so they are not supposed to be
used to implement business logic. Instead, they are useful for audit trail. Or we have audit trail builtin,
eliminate the need for hooks.
